/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
/*!***********************************************************!*\
  !*** ./src/workers/data/dist/node_modules/data-worker.js ***!
  \***********************************************************/
__webpack_require__.r(__webpack_exports__);
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function tidy(items, ...fns) {
  if (typeof items === "function") {
    throw new Error("You must supply the data as the first argument to tidy()");
  }

  let result = items;

  for (const fn of fns) {
    if (fn) {
      result = fn(result);
    }
  }

  return result;
}

function filter(filterFn) {
  const _filter = items => items.filter(filterFn);

  return _filter;
}

function singleOrArray(d) {
  return d == null ? [] : Array.isArray(d) ? d : [d];
}

function ascending$1 (a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;

    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }

  add(x) {
    const p = this._partials;
    let i = 0;

    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
            hi = x + y,
            lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }

    p[i] = x;
    this._n = i + 1;
    return this;
  }

  valueOf() {
    const p = this._partials;
    let n = this._n,
        x,
        y,
        lo,
        hi = 0;

    if (n > 0) {
      hi = p[--n];

      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }

      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }

    return hi;
  }

}
function fsum(values, valueof) {
  const adder = new Adder();

  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;

    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }

  return +adder;
}

class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, {
      _intern: {
        value: new Map()
      },
      _key: {
        value: key
      }
    });
    if (entries != null) for (const [_key2, value] of entries) this.set(_key2, value);
  }

  get(key) {
    return super.get(intern_get(this, key));
  }

  has(key) {
    return super.has(intern_get(this, key));
  }

  set(key, value) {
    return super.set(intern_set(this, key), value);
  }

  delete(key) {
    return super.delete(intern_delete(this, key));
  }

}

function intern_get({
  _intern,
  _key
}, value) {
  const key = _key(value);

  return _intern.has(key) ? _intern.get(key) : value;
}

function intern_set({
  _intern,
  _key
}, value) {
  const key = _key(value);

  if (_intern.has(key)) return _intern.get(key);

  _intern.set(key, value);

  return value;
}

function intern_delete({
  _intern,
  _key
}, value) {
  const key = _key(value);

  if (_intern.has(key)) {
    value = _intern.get(value);

    _intern.delete(key);
  }

  return value;
}

function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}

function identity$2 (x) {
  return x;
}

function group(values, ...keys) {
  return nest(values, identity$2, identity$2, keys);
}

function nest(values, map, reduce, keys) {
  return function regroup(values, i) {
    if (i >= keys.length) return reduce(values);
    const groups = new InternMap();
    const keyof = keys[i++];
    let index = -1;

    for (const value of values) {
      const key = keyof(value, ++index, values);
      const group = groups.get(key);
      if (group) group.push(value);else groups.set(key, [value]);
    }

    for (const [key, _values] of groups) {
      groups.set(key, regroup(_values, i));
    }

    return map(groups);
  }(values, 0);
}

function max$1(values, valueof) {
  let max;

  if (valueof === undefined) {
    for (const value of values) {
      if (value != null && (max < value || max === undefined && value >= value)) {
        max = value;
      }
    }
  } else {
    let index = -1;

    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (max < value || max === undefined && value >= value)) {
        max = value;
      }
    }
  }

  return max;
}

function min$1(values, valueof) {
  let min;

  if (valueof === undefined) {
    for (const value of values) {
      if (value != null && (min > value || min === undefined && value >= value)) {
        min = value;
      }
    }
  } else {
    let index = -1;

    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (min > value || min === undefined && value >= value)) {
        min = value;
      }
    }
  }

  return min;
}

// ISC license, Copyright 2018 Vladimir Agafonkin.

function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending$1) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;
    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;

      while (compare(array[i], t) < 0) ++i;

      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);else ++j, swap(array, j, right);
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }

  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}

function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return min$1(values);
  if (p >= 1) return max$1(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = max$1(quickselect(values, i0).subarray(0, i0 + 1)),
      value1 = min$1(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function median$1 (values, valueof) {
  return quantile(values, 0.5, valueof);
}

function arrange(comparators) {
  const _arrange = items => {
    const comparatorFns = singleOrArray(comparators).map(comp => typeof comp === "function" ? comp : asc(comp));
    return items.slice().sort((a, b) => {
      for (const comparator of comparatorFns) {
        const result = comparator(a, b);
        if (result) return result;
      }

      return 0;
    });
  };

  return _arrange;
}

function asc(key) {
  const keyFn = typeof key === "function" ? key : d => d[key];
  return function _asc(a, b) {
    return emptyAwareComparator(keyFn(a), keyFn(b), false);
  };
}

function desc(key) {
  const keyFn = typeof key === "function" ? key : d => d[key];
  return function _desc(a, b) {
    return emptyAwareComparator(keyFn(a), keyFn(b), true);
  };
}

function emptyAwareComparator(aInput, bInput, desc2) {
  let a = desc2 ? bInput : aInput;
  let b = desc2 ? aInput : bInput;

  if (isEmpty(a) && isEmpty(b)) {
    const rankA = a !== a ? 0 : a === null ? 1 : 2;
    const rankB = b !== b ? 0 : b === null ? 1 : 2;
    const order = rankA - rankB;
    return desc2 ? -order : order;
  }

  if (isEmpty(a)) {
    return desc2 ? -1 : 1;
  }

  if (isEmpty(b)) {
    return desc2 ? 1 : -1;
  }

  return ascending$1(a, b);
}

function isEmpty(value) {
  return value == null || value !== value;
}

function summarize(summarizeSpec, options) {
  const _summarize = items => {
    options = options != null ? options : {};
    const summarized = {};
    const keys = Object.keys(summarizeSpec);

    for (const key of keys) {
      summarized[key] = summarizeSpec[key](items);
    }

    if (options.rest && items.length) {
      const objectKeys = Object.keys(items[0]);

      for (const objKey of objectKeys) {
        if (keys.includes(objKey)) {
          continue;
        }

        summarized[objKey] = options.rest(objKey)(items);
      }
    }

    return [summarized];
  };

  return _summarize;
}

function mutate(mutateSpec) {
  const _mutate = items => {
    const mutatedItems = [];

    for (const item of items) {
      const mutatedItem = _extends({}, item);

      for (const key in mutateSpec) {
        const mutateSpecValue = mutateSpec[key];
        const mutatedResult = typeof mutateSpecValue === "function" ? mutateSpecValue(mutatedItem) : mutateSpecValue;
        mutatedItem[key] = mutatedResult;
      }

      mutatedItems.push(mutatedItem);
    }

    return mutatedItems;
  };

  return _mutate;
}

function assignGroupKeys(d, keys) {
  if (d == null || typeof d !== "object" || Array.isArray(d)) return d;
  const keysObj = Object.fromEntries(keys.filter(key => typeof key[0] !== "function"));
  return Object.assign(keysObj, d);
}

function groupTraversal(grouped, outputGrouped, keys, addSubgroup, addLeaves, level = 0) {
  for (const [key, value] of grouped.entries()) {
    const keysHere = [...keys, key];

    if (value instanceof Map) {
      const subgroup = addSubgroup(outputGrouped, keysHere, level);
      groupTraversal(value, subgroup, keysHere, addSubgroup, addLeaves, level + 1);
    } else {
      addLeaves(outputGrouped, keysHere, value, level);
    }
  }

  return outputGrouped;
}

function groupMap(grouped, groupFn, keyFn = keys => keys[keys.length - 1]) {
  function addSubgroup(parentGrouped, keys) {
    const subgroup = new Map();
    parentGrouped.set(keyFn(keys), subgroup);
    return subgroup;
  }

  function addLeaves(parentGrouped, keys, values) {
    parentGrouped.set(keyFn(keys), groupFn(values, keys));
  }

  const outputGrouped = new Map();
  groupTraversal(grouped, outputGrouped, [], addSubgroup, addLeaves);
  return outputGrouped;
}

const identity$1 = d => d;

function groupBy(groupKeys, fns, options) {
  if (typeof fns === "function") {
    fns = [fns];
  } else if (arguments.length === 2 && fns != null && !Array.isArray(fns)) {
    options = fns;
  }

  const _groupBy = items => {
    const grouped = makeGrouped(items, groupKeys);
    const results = runFlow(grouped, fns, options == null ? void 0 : options.addGroupKeys);

    if (options == null ? void 0 : options.export) {
      switch (options.export) {
        case "grouped":
          return results;

        case "levels":
          return exportLevels(results, options);

        case "entries-obj":
        case "entriesObject":
          return exportLevels(results, _extends({}, options, {
            export: "levels",
            levels: ["entries-object"]
          }));

        default:
          return exportLevels(results, _extends({}, options, {
            export: "levels",
            levels: [options.export]
          }));
      }
    }

    const ungrouped = ungroup(results, options == null ? void 0 : options.addGroupKeys);
    return ungrouped;
  };

  return _groupBy;
}

groupBy.grouped = options => _extends({}, options, {
  export: "grouped"
});

groupBy.entries = options => _extends({}, options, {
  export: "entries"
});

groupBy.entriesObject = options => _extends({}, options, {
  export: "entries-object"
});

groupBy.object = options => _extends({}, options, {
  export: "object"
});

groupBy.map = options => _extends({}, options, {
  export: "map"
});

groupBy.keys = options => _extends({}, options, {
  export: "keys"
});

groupBy.values = options => _extends({}, options, {
  export: "values"
});

groupBy.levels = options => _extends({}, options, {
  export: "levels"
});

function runFlow(items, fns, addGroupKeys) {
  let result = items;
  if (!(fns == null ? void 0 : fns.length)) return result;

  for (const fn of fns) {
    if (!fn) continue;
    result = groupMap(result, (items2, keys) => {
      const context = {
        groupKeys: keys
      };
      let leafItemsMapped = fn(items2, context);

      if (addGroupKeys !== false) {
        leafItemsMapped = leafItemsMapped.map(item => assignGroupKeys(item, keys));
      }

      return leafItemsMapped;
    });
  }

  return result;
}

function makeGrouped(items, groupKeys) {
  const groupKeyFns = singleOrArray(groupKeys).map((key, i) => {
    const keyFn = typeof key === "function" ? key : d => d[key];
    const keyCache = new Map();
    return d => {
      const keyValue = keyFn(d);

      if (keyCache.has(keyValue)) {
        return keyCache.get(keyValue);
      }

      const keyWithName = [key, keyValue];
      keyCache.set(keyValue, keyWithName);
      return keyWithName;
    };
  });
  const grouped = group(items, ...groupKeyFns);
  return grouped;
}

function ungroup(grouped, addGroupKeys) {
  const items = [];
  groupTraversal(grouped, items, [], identity$1, (root, keys, values) => {
    let valuesToAdd = values;

    if (addGroupKeys !== false) {
      valuesToAdd = values.map(d => assignGroupKeys(d, keys));
    }

    root.push(...valuesToAdd);
  });
  return items;
}

const defaultCompositeKey = keys => keys.join("/");

function processFromGroupsOptions(options) {
  var _a;

  const {
    flat,
    single,
    mapLeaf = identity$1,
    mapLeaves = identity$1,
    addGroupKeys
  } = options;
  let compositeKey;

  if (options.flat) {
    compositeKey = (_a = options.compositeKey) != null ? _a : defaultCompositeKey;
  }

  const groupFn = (values, keys) => {
    return single ? mapLeaf(addGroupKeys === false ? values[0] : assignGroupKeys(values[0], keys)) : mapLeaves(values.map(d => mapLeaf(addGroupKeys === false ? d : assignGroupKeys(d, keys))));
  };

  const keyFn = flat ? keys => compositeKey(keys.map(d => d[1])) : keys => keys[keys.length - 1][1];
  return {
    groupFn,
    keyFn
  };
}

function exportLevels(grouped, options) {
  const {
    groupFn,
    keyFn
  } = processFromGroupsOptions(options);
  let {
    mapEntry = identity$1
  } = options;
  const {
    levels = ["entries"]
  } = options;
  const levelSpecs = [];

  for (const levelOption of levels) {
    switch (levelOption) {
      case "entries":
      case "entries-object":
      case "entries-obj":
      case "entriesObject":
        {
          const levelMapEntry = (levelOption === "entries-object" || levelOption === "entries-obj" || levelOption === "entriesObject") && options.mapEntry == null ? ([key, values]) => ({
            key,
            values
          }) : mapEntry;
          levelSpecs.push({
            id: "entries",
            createEmptySubgroup: () => [],
            addSubgroup: (parentGrouped, newSubgroup, key, level) => {
              parentGrouped.push(levelMapEntry([key, newSubgroup], level));
            },
            addLeaf: (parentGrouped, key, values, level) => {
              parentGrouped.push(levelMapEntry([key, values], level));
            }
          });
          break;
        }

      case "map":
        levelSpecs.push({
          id: "map",
          createEmptySubgroup: () => new Map(),
          addSubgroup: (parentGrouped, newSubgroup, key) => {
            parentGrouped.set(key, newSubgroup);
          },
          addLeaf: (parentGrouped, key, values) => {
            parentGrouped.set(key, values);
          }
        });
        break;

      case "object":
        levelSpecs.push({
          id: "object",
          createEmptySubgroup: () => ({}),
          addSubgroup: (parentGrouped, newSubgroup, key) => {
            parentGrouped[key] = newSubgroup;
          },
          addLeaf: (parentGrouped, key, values) => {
            parentGrouped[key] = values;
          }
        });
        break;

      case "keys":
        levelSpecs.push({
          id: "keys",
          createEmptySubgroup: () => [],
          addSubgroup: (parentGrouped, newSubgroup, key) => {
            parentGrouped.push([key, newSubgroup]);
          },
          addLeaf: (parentGrouped, key) => {
            parentGrouped.push(key);
          }
        });
        break;

      case "values":
        levelSpecs.push({
          id: "values",
          createEmptySubgroup: () => [],
          addSubgroup: (parentGrouped, newSubgroup) => {
            parentGrouped.push(newSubgroup);
          },
          addLeaf: (parentGrouped, key, values) => {
            parentGrouped.push(values);
          }
        });
        break;

      default:
        {
          if (typeof levelOption === "object") {
            levelSpecs.push(levelOption);
          }
        }
    }
  }

  const addSubgroup = (parentGrouped, keys, level) => {
    var _a, _b;

    if (options.flat) {
      return parentGrouped;
    }

    const levelSpec = (_a = levelSpecs[level]) != null ? _a : levelSpecs[levelSpecs.length - 1];
    const nextLevelSpec = (_b = levelSpecs[level + 1]) != null ? _b : levelSpec;
    const newSubgroup = nextLevelSpec.createEmptySubgroup();
    levelSpec.addSubgroup(parentGrouped, newSubgroup, keyFn(keys), level);
    return newSubgroup;
  };

  const addLeaf = (parentGrouped, keys, values, level) => {
    var _a;

    const levelSpec = (_a = levelSpecs[level]) != null ? _a : levelSpecs[levelSpecs.length - 1];
    levelSpec.addLeaf(parentGrouped, keyFn(keys), groupFn(values, keys), level);
  };

  const initialOutputObject = levelSpecs[0].createEmptySubgroup();
  return groupTraversal(grouped, initialOutputObject, [], addSubgroup, addLeaf);
}

function keysFromItems(items) {
  if (items.length < 1) return [];
  const keys = Object.keys(items[0]);
  return keys;
}

function everything() {
  return items => {
    const keys = keysFromItems(items);
    return keys;
  };
}

function processSelectors(items, selectKeys) {
  let processedSelectKeys = [];

  for (const keyInput of singleOrArray(selectKeys)) {
    if (typeof keyInput === "function") {
      processedSelectKeys.push(...keyInput(items));
    } else {
      processedSelectKeys.push(keyInput);
    }
  }

  if (processedSelectKeys.length && processedSelectKeys[0][0] === "-") {
    processedSelectKeys = [...everything()(items), ...processedSelectKeys];
  }

  const negationMap = {};
  const keysWithoutNegations = [];

  for (let k = processedSelectKeys.length - 1; k >= 0; k--) {
    const key = processedSelectKeys[k];

    if (key[0] === "-") {
      negationMap[key.substring(1)] = true;
      continue;
    }

    if (negationMap[key]) {
      negationMap[key] = false;
      continue;
    }

    keysWithoutNegations.unshift(key);
  }

  processedSelectKeys = Array.from(new Set(keysWithoutNegations));
  return processedSelectKeys;
}

function select(selectKeys) {
  const _select = items => {
    let processedSelectKeys = processSelectors(items, selectKeys);
    if (!processedSelectKeys.length) return items;
    return items.map(d => {
      const mapped = {};

      for (const key of processedSelectKeys) {
        mapped[key] = d[key];
      }

      return mapped;
    });
  };

  return _select;
}

function mean$1(items, accessor) {
  let n = 0;

  for (let i = 0; i < items.length; ++i) {
    const value = accessor(items[i], i, items);

    if (+value === value) {
      n += 1;
    }
  }

  return n ? fsum(items, accessor) / n : void 0;
}

function min(key) {
  const keyFn = typeof key === "function" ? key : d => d[key];
  return items => min$1(items, keyFn);
}

function max(key) {
  const keyFn = typeof key === "function" ? key : d => d[key];
  return items => max$1(items, keyFn);
}

function mean(key) {
  const keyFn = typeof key === "function" ? key : d => d[key];
  return items => mean$1(items, keyFn);
}

function median(key) {
  const keyFn = typeof key === "function" ? key : d => d[key];
  return items => median$1(items, keyFn);
}

function ascending (a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector (f) {
  let delta = f;
  let compare = f;

  if (f.length === 1) {
    delta = (d, x) => f(d) - x;

    compare = ascendingComparator(f);
  }

  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
    }

    return lo;
  }

  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
    }

    return lo;
  }

  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {
    left,
    center,
    right
  };
}

function ascendingComparator(f) {
  return (d, x) => ascending(f(d), x);
}

function number (x) {
  return x === null ? NaN : +x;
}

const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
bisector(number).center;

function count(values, valueof) {
  let count = 0;

  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count;
      }
    }
  } else {
    let index = -1;

    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count;
      }
    }
  }

  return count;
}

function extent (values, valueof) {
  let min;
  let max;

  if (valueof === undefined) {
    for (const value of values) {
      if (value != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  } else {
    let index = -1;

    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null) {
        if (min === undefined) {
          if (value >= value) min = max = value;
        } else {
          if (min > value) min = value;
          if (max < value) max = value;
        }
      }
    }
  }

  return [min, max];
}

function identity (x) {
  return x;
}

var array = Array.prototype;
var slice = array.slice;

function constant (x) {
  return function () {
    return x;
  };
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);
function ticks (start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    let r0 = Math.round(start / step),
        r1 = Math.round(stop / step);
    if (r0 * step < start) ++r0;
    if (r1 * step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);

    while (++i < n) ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step),
        r1 = Math.round(stop * step);
    if (r0 / step < start) ++r0;
    if (r1 / step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);

    while (++i < n) ticks[i] = (r0 + i) / step;
  }

  if (reverse) ticks.reverse();
  return ticks;
}
function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function nice(start, stop, count) {
  let prestep;

  while (true) {
    const step = tickIncrement(start, stop, count);

    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start, stop];
    } else if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
    }

    prestep = step;
  }
}

function sturges (values) {
  return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;
}

function bin () {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1); // Convert number of thresholds into uniform thresholds, and nice the
    // default domain accordingly.

    if (!Array.isArray(tz)) {
      const max = x1,
            tn = +tz;
      if (domain === extent) [x0, x1] = nice(x0, x1, tn);
      tz = ticks(x0, x1, tn); // If the last threshold is coincident with the domain’s upper bound, the
      // last bin will be zero-width. If the default domain is used, and this
      // last threshold is coincident with the maximum input value, we can
      // extend the niced upper bound by one tick to ensure uniform bin widths;
      // otherwise, we simply remove the last threshold. Note that we don’t
      // coerce values or the domain to numbers, and thus must be careful to
      // compare order (>=) rather than strict equality (===)!

      if (tz[tz.length - 1] >= x1) {
        if (max >= x1 && domain === extent) {
          const step = tickIncrement(x0, x1, tn);

          if (isFinite(step)) {
            if (step > 0) {
              x1 = (Math.floor(x1 / step) + 1) * step;
            } else if (step < 0) {
              x1 = (Math.ceil(x1 * -step) + 1) / -step;
            }
          }
        } else {
          tz.pop();
        }
      }
    } // Remove any thresholds outside the domain.


    var m = tz.length;

    while (tz[0] <= x0) tz.shift(), --m;

    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin; // Initialize bins.

    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    } // Assign data to bins by value, ignoring any outside the domain.


    for (i = 0; i < n; ++i) {
      x = values[i];

      if (x != null && x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function (_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

const _excluded = ["worker", "data", "previousData"];

const handlers = {
  arrange: props => {
    const {
      column,
      descending,
      data
    } = props;
    return tidy(data, arrange(descending ? desc(column) : column));
  },
  select: props => {
    const {
      columns,
      data
    } = props;
    if (!columns) return data;else return tidy(data, select(columns.map(column => `${column}`)));
  },
  drop: props => {
    const {
      columns,
      data
    } = props;
    if (!columns) return data;else return tidy(data, select(columns.map(column => `-${column}`)));
  },
  filter_string: props => {
    const {
      column,
      logic,
      rhs,
      data
    } = props;
    if (!column || rhs === undefined) return data;

    switch (logic) {
      case "gt":
        return tidy(data, filter(d => d[column] > rhs));

      case "lt":
        return tidy(data, filter(d => d[column] < rhs));

      case "ge":
        return tidy(data, filter(d => d[column] >= rhs));

      case "le":
        return tidy(data, filter(d => d[column] <= rhs));

      case "eq":
        return tidy(data, filter(d => d[column] == rhs));

      case "ne":
        return tidy(data, filter(d => d[column] != rhs));

      default:
        return data;
    }
  },
  filter_columns: props => {
    const {
      columns,
      logic,
      data
    } = props;
    const [left, right] = columns;
    if (!left || !right) return data;

    switch (logic) {
      case "gt":
        return tidy(data, filter(d => d[columns[0]] > d[columns[1]]));

      case "lt":
        return tidy(data, filter(d => d[columns[0]] < d[columns[1]]));

      case "ge":
        return tidy(data, filter(d => d[columns[0]] >= d[columns[1]]));

      case "le":
        return tidy(data, filter(d => d[columns[0]] <= d[columns[1]]));

      case "eq":
        return tidy(data, filter(d => d[columns[0]] === d[columns[1]]));

      case "ne":
        return tidy(data, filter(d => d[columns[0]] !== d[columns[1]]));

      default:
        return data;
    }
  },
  mutate_columns: props => {
    const {
      newcolumn,
      lhs,
      rhs,
      logic,
      data
    } = props;
    if (newcolumn === undefined || !lhs || !rhs || !logic) return data;
    const calc = {};

    switch (logic) {
      case "plus":
        calc[newcolumn] = d => d[lhs] + d[rhs];

        return tidy(data, mutate(calc));

      case "minus":
        calc[newcolumn] = d => d[lhs] - d[rhs];

        return tidy(data, mutate(calc));

      case "mult":
        calc[newcolumn] = d => d[lhs] * d[rhs];

        return tidy(data, mutate(calc));

      case "div":
        calc[newcolumn] = d => d[lhs] / d[rhs];

        return tidy(data, mutate(calc));

      case "gt":
        calc[newcolumn] = d => d[lhs] > d[rhs];

        return tidy(data, mutate(calc));

      case "lt":
        calc[newcolumn] = d => d[lhs] < d[rhs];

        return tidy(data, mutate(calc));

      case "ge":
        calc[newcolumn] = d => d[lhs] >= d[rhs];

        return tidy(data, mutate(calc));

      case "le":
        calc[newcolumn] = d => d[lhs] <= d[rhs];

        return tidy(data, mutate(calc));

      case "eq":
        calc[newcolumn] = d => d[lhs] == d[rhs];

        return tidy(data, mutate(calc));

      case "ne":
        calc[newcolumn] = d => d[lhs] != d[rhs];

        return tidy(data, mutate(calc));

      default:
        return data;
    }
  },
  mutate_number: props => {
    const {
      newcolumn,
      lhs,
      rhs,
      logic,
      data
    } = props;
    if (newcolumn === undefined || !lhs || rhs === undefined || !logic) return data;
    const calc = {};

    switch (logic) {
      case "plus":
        calc[newcolumn] = d => d[lhs] + rhs;

        return tidy(data, mutate(calc));

      case "minus":
        calc[newcolumn] = d => d[lhs] - rhs;

        return tidy(data, mutate(calc));

      case "mult":
        calc[newcolumn] = d => d[lhs] * rhs;

        return tidy(data, mutate(calc));

      case "div":
        calc[newcolumn] = d => d[lhs] / rhs;

        return tidy(data, mutate(calc));

      case "gt":
        calc[newcolumn] = d => d[lhs] > rhs;

        return tidy(data, mutate(calc));

      case "lt":
        calc[newcolumn] = d => d[lhs] < rhs;

        return tidy(data, mutate(calc));

      case "ge":
        calc[newcolumn] = d => d[lhs] >= rhs;

        return tidy(data, mutate(calc));

      case "le":
        calc[newcolumn] = d => d[lhs] <= rhs;

        return tidy(data, mutate(calc));

      case "eq":
        calc[newcolumn] = d => d[lhs] == rhs;

        return tidy(data, mutate(calc));

      case "ne":
        calc[newcolumn] = d => d[lhs] != rhs;

        return tidy(data, mutate(calc));

      default:
        return data;
    }
  },
  summarize_by_group: props => {
    const {
      column,
      by,
      calc,
      data
    } = props;
    if (!column || !by || !calc) return data;

    switch (calc) {
      case "mean":
        return tidy(data, // eslint-disable-next-line @typescript-eslint/no-explicit-any
        groupBy(by, [// eslint-disable-next-line @typescript-eslint/no-explicit-any
        summarize({
          Mean: mean(column)
        })]));

      case "med":
        return tidy(data, // eslint-disable-next-line @typescript-eslint/no-explicit-any
        groupBy(by, [// eslint-disable-next-line @typescript-eslint/no-explicit-any
        summarize({
          Median: median(column)
        })]));

      case "min":
        return tidy(data, // eslint-disable-next-line @typescript-eslint/no-explicit-any
        groupBy(by, [summarize({
          Min: min(column)
        })]));

      case "max":
        return tidy(data, // eslint-disable-next-line @typescript-eslint/no-explicit-any
        groupBy(by, [summarize({
          Max: max(column)
        })]));

      default:
        return data;
    }
  },
  record_window: props => {
    var _previousData;

    const {
      data,
      previousData,
      horizon
    } = props;
    if (!(data != null && data.length)) return data;
    const now = data[data.length - 1].time;
    const previousNow = previousData == null ? void 0 : (_previousData = previousData[(previousData == null ? void 0 : previousData.length) - 1]) == null ? void 0 : _previousData.time;
    if (now === undefined || previousNow === undefined) return data.filter(r => now - r.time < horizon);
    return [...previousData.filter(r => now - r.time < horizon), ...data.filter(r => now - r.time < horizon && r.time > previousNow)];
  },
  bin: props => {
    const {
      data,
      column
    } = props;
    const binner = bin().value(d => d[column]);
    const binned = binner(data); // convert back to objects

    return binned.map(b => ({
      length: b.length,
      x0: b.x0,
      x1: b.x1
    }));
  }
};

function transformData(message) {
  try {
    const handler = handlers[message.type];
    return handler == null ? void 0 : handler(message);
  } catch (e) {
    console.debug(e);
    return undefined;
  }
}

async function handleMessage(event) {
  const message = event.data; // eslint-disable-next-line @typescript-eslint/no-unused-vars

  const {
    worker
  } = message,
        rest = _objectWithoutPropertiesLoose(message, _excluded);

  if (worker !== "data") return; //console.debug("Jacdac data in:", { message })

  const newData = await transformData(message); //console.debug("Jacdac data out:", { message })

  const resp = _extends({
    worker
  }, rest, {
    data: newData
  });

  self.postMessage(resp);
}

self.addEventListener("message", handleMessage);
console.debug(`jacdac data: worker registered`);
//# sourceMappingURL=data-worker.js.map

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ })()
;
//# sourceMappingURL=vendors-src_workers_data_dist_node_modules_data-worker_js.render-page.js.map